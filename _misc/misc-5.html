---
title: "Smoothing .obj 3D models"
excerpt: "<br/><img src='/images/misc/obj-smoothing/smoothing1.png'><br/><small></small>"
collection: misc
tags:
  - computer-graphics
  - .obj-smoothing
  - Blender
---

<hr style="border-color: silver;">
<!--<large>Source:</large> -->
<!--<iframe src="https://ghbtns.com/github-btn.html?user=gurumulay&repo=big-data-class/tree/master/n-gram-analysis-of-gutenberg&type=star&count=false&size=large" frameborder="0" scrolling="0" width="160px" height="30px"></iframe>-->
<hr style="border-color: silver;">



<!--##############-->
<hr>
<p>
    <big>
    <b>Introduction:</b>
    </big>
</p>

<p>
    A .obj file is usually defined in terms of triangle that form the faces of a 3D object. They follow
    <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">Wavefront .obj</a> file format.
    Each face and vertex forming that face has a normal associated with it. The transition of these normals going from
    one face to the next adjacent face is not smooth. When you render a .obj file without smoothing these normals, you
    get a object that shows triangular artifacts as shown in the Figure 2a. With this approach, for every location on a
    specific triangular face, there is single normal associated with it. This normal ($N_{true}$) can either be read from
    the .obj file or can be calculated using cross product of the edge vectors of that triangle using the formula in \eqref{eq:nt1}.

    <br/>
    \begin{equation}
    N_{true} = (A - B) \times (A - C)
    \label{eq:nt1}
    \end{equation}
    <br/>

</p>


<p>
    However, it is possible to get a smooth rendering of a .obj file by smoothing out the transitions of normals going
    from one face to the adjacent faces. With this approach, the normal at a point on the triangular face is calculated
    dynamically depending on what point we want to render on our image plane. In this case, the normal at point $I$ on a
    triangular face is defined by \eqref{eq:ni1}

    <br/>
    \begin{equation}
    N_{true} = (1 - \beta - \gamma)*N_{A} + \beta*N_{B} + \gamma*N_{C}
    \label{eq:ni1}
    \end{equation}
    <br/>

    Here, $N_{A}$, $N_{B}$, and $N_{C}$ are the mean normals at vertex $A$, $B$, and $C$ respectively of the
    triangular face. The constants $\beta$ and $\gamma$ are the distances of point $I$ from vertex $A$ along the edges
    of the triangular face.

</p>


<p>
    <br style="margin-bottom:10px;"/>
    <div style="text-align: center">
        <a href="/images/misc/obj-smoothing/face1.png">
            <img src="/images/misc/obj-smoothing/face1.png" alt="Illustration on finding 'smooth' normal" align="middle" hspace="0" height="700">
        </a>
        <br/>
        <br/>
        <figcaption>Fig. 1: Illustration on finding 'smooth' normal</figcaption>
    </div>
</p>


<p>
    Now, the mean normal at any vertex, say vertex $A$, can be found using simply averaging the $N_{true}$ of all the
    triangular faces in that .obj file that share the vertex $A$ using \eqref{eq:av1}.

    <br/>
    \begin{equation}
    N_{A} = mean(N1_{true}, N2_{true}, N3_{true}, N4_{true}, ....)
    \label{eq:av1}
    \end{equation}
    <br/>

    You can find the mean normals for vertex $B$ and $C$ using similar logic.

    <br/>
    <br/>

    However, there is one more check that ensures that we are not smoothing out the edges of sharp objects such as a cube.
    With cube, you should not find mean of two adjacent triangles belonging to adjacent square faces of the cube, because
    that will smooth out the edge of the cube that we do not intend to smooth. Similar goes with the corners of the cube or the
    pointy horn of the cow in Figure 3a which should not be smoothed. Therefore to avoid smoothing the sharp parts of the
    .obj file you should ensure that when finding the mean vertex normal (as in \eqref{eq:av1}), the normals that are being
    averaged are within some angle $\delta$ of the $N1_{true}$ of the face in consideration. Figure 3b shows smoothing with
    $\delta = 22^\text{o}$. For Figure, 4 and 5 the $\delta$ is gradually increased with $\delta$ equal to $30^\text{o}$,
    $45^\text{o}$, and  $60^\text{o}$. As you can see, with higher $\delta$ threshold we get more smoothly rendered object.

</p>


<p>
    <br style="margin-bottom:10px;"/>
    <div style="text-align: center">
        <a href="https://farm5.staticflickr.com/4835/30852606017_7c22d12335_o.jpg">
            <img alt="A sphere made of triangles (.obj file): before smoothing" src="https://farm5.staticflickr.com/4835/30852606017_7c22d12335_o.jpg" style="float: left; width: 49%; margin-right: 1%; margin-bottom: 1em;"></a>
        <a href="https://farm5.staticflickr.com/4805/31921125568_5658cb1714_o.jpg">
            <img alt="A sphere made of triangles (.obj file): after smoothing" src="https://farm5.staticflickr.com/4805/31921125568_5658cb1714_o.jpg" style="float: left; width: 49%; margin-right: 1%; margin-bottom: 1em;"></a>
        <br/>
        <br/>
        <figcaption>Fig. 2: A sphere made of triangles (.obj file): before and after smoothing</figcaption>
    </div>
</p>


<p>
    <br style="margin-bottom:10px;"/>
    <div style="text-align: center">
        <a href="https://farm5.staticflickr.com/4872/30862525147_a0d60d4c45_o.jpg">
            <img alt="A cow made of triangles (.obj file): before smoothing" src="https://farm5.staticflickr.com/4872/30862525147_a0d60d4c45_o.jpg" style="float: left; width: 49%; margin-right: 1%; margin-bottom: 1em;"></a>
        <a href="https://farm5.staticflickr.com/4840/30862525327_a9b6f0854e_o.jpg">
            <img alt="A cow made of triangles (.obj file): after smoothing" src="https://farm5.staticflickr.com/4840/30862525327_a9b6f0854e_o.jpg" style="float: left; width: 49%; margin-right: 1%; margin-bottom: 1em;"></a>
        <br/>
        <br/>
        <figcaption>Fig. 3: A cow made of triangles (.obj file): before and after smoothing (smoothing angle = 22 degrees)</figcaption>
    </div>
</p>


<p>
    <br style="margin-bottom:10px;"/>
    <div style="text-align: center">
        <a href="https://farm5.staticflickr.com/4804/45077653724_bcc038dd36_o.jpg">
            <img alt="A cow made of triangles (.obj file): before smoothing" src="https://farm5.staticflickr.com/4804/45077653724_bcc038dd36_o.jpg" style="float: left; width: 49%; margin-right: 1%; margin-bottom: 1em;"></a>
        <a href="https://farm5.staticflickr.com/4823/30862525257_831c176a66_o.jpg">
            <img alt="A cow made of triangles (.obj file): after smoothing" src="https://farm5.staticflickr.com/4823/30862525257_831c176a66_o.jpg" style="float: left; width: 49%; margin-right: 1%; margin-bottom: 1em;"></a>
        <br/>
        <br/>
        <figcaption>Fig. 4: Progressive smoothing (smoothing angles are 30 and 45 degrees)</figcaption>
    </div>
</p>



<p>
    <br style="margin-bottom:10px;"/>
    <div style="text-align: center">
        <a href="https://farm5.staticflickr.com/4819/30862525197_fc847eb611_o.jpg">
            <img src="https://farm5.staticflickr.com/4819/30862525197_fc847eb611_o.jpg" alt="A smoothed cow (cow.obj file)" align="middle" hspace="0" height="700">
        </a>
        <br/>
        <br/>
        <figcaption>Fig. 5: A smoothed cow (cow.obj file) with smoothing angle = 60 degrees</figcaption>
    </div>
</p>


<!--<p>-->
    <!--In 3D graphics, people often use geometry definition file formats such as-->
    <!--<a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">Wavefront .obj format</a>-->
    <!--or <a href="https://en.wikipedia.org/wiki/PLY_(file_format)">Polygonal File Format .ply </a>-->
    <!--to render objects in a scene. These formats store the object in that are defined in terms of polygons.-->
    <!--These objects are stored in a 3D reference frame of its own. When you have to render multiple objects with their-->
    <!--own frame of reference into one scene having a global (world) frame of reference, you need to transform individual-->
    <!--objects into that world frame of reference.-->
    <!--<br/>-->
    <!--Transformation of a 3D object from one frame of reference to another can be achieved by a series of transformations-->
    <!--such as Rotation, Scale, and Translation. These transformations are applied to points in 3D that describe the-->
    <!--vertices of our polygonal objects. We will go over individual transformation below.-->
<!--</p>-->


<!--<p>-->
    <!--You can read more about the internals of this project <a href="https://www.cs.colostate.edu/~cs410/yr2017fa/more_assignments/assignment01.php">here</a>.-->
<!--</p>-->


<!--&lt;!&ndash;##############&ndash;&gt;-->
<!--<hr>-->
<!--<p>-->
    <!--<big>-->
    <!--<b>Rotation (Axis-Angle-Rotation Technique):</b>-->
    <!--</big>-->
<!--</p>-->

<!--<p>-->
    <!--<a href="https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation">Axis-angle rotation technique</a>-->
    <!--is a standard way to rotate about a specified axis-->
    <!--<code>wx wy wz</code> by a specified angle <code>theta</code> in radians.-->

<!--</p>-->

<!--<p>-->
<!--Axis-angle rotation can be divided into three steps as follows:-->

<!--<ol type="1">-->

    <!--<li>Rotate data points to make axis-z the axis of rotation.</li>-->
    <!--<li>Rotate data points about axis-z.</li>-->
    <!--<li>Apply the inverse of the original rotation from step 1.</li>-->
<!--</ol>-->

<!--So for a set of 3D points represented by $P$, we get corresponding 'rotated' set of points $P'$ using the-->
<!--equation:-->

    <!--<br/>-->
    <!--\begin{equation}-->
    <!--P' = ({R_{w}^{-1} R_{Z_{Theta}} R_{w}}) \cdot {P}-->
    <!--\label{eq:t1}-->
    <!--\end{equation}-->
    <!--<br/>-->

    <!--where, each $R$ matrix (from right to left) corresponds to one step from 3 steps described above.-->
    <!--Here, we represent point $P_{A}$ in <a href="https://en.wikipedia.org/wiki/Homogeneous_coordinates">homogeneous coordinates</a>-->
    <!--format with $w = 1$.-->

    <!--<br/>-->
    <!--<br/>-->
    <!--Therefore, $P_{A} = [x,  y,  z,  w]'$-->

<!--</p>-->


<!--<p>-->
    <!--<b>Step 1 - $R_{w}$:</b>-->
    <!--<br/>-->
    <!--$R_{w}$ is defined as below:-->
<!--</p>-->


<!--<p>-->
    <!--<br style="margin-bottom:10px;"/>-->
    <!--<div style="text-align: center">-->
        <!--<a href="/images/misc/transformations/rw1.png">-->
            <!--<img src="/images/misc/transformations/rw1.png" alt="Rotation matrix to make axis-z the axis of rotation" align="middle" hspace="30" height="300">-->
        <!--</a>-->
        <!--<br/>-->
        <!--<figcaption>Rotation matrix to make axis-z the axis of rotation</figcaption>-->
    <!--</div>-->
    <!--<br/>-->
<!--</p>-->



<!--<p>-->
    <!--<b>Step 2 - $R_{Z_{Theta}}$:</b>-->
    <!--<br/>-->
    <!--$R_{Z_{Theta}}$ is a standard rotation matrix to rotate about axis-z. Now using-->
    <!--<a href="https://en.wikipedia.org/wiki/Euler%27s_rotation_theorem">Euler's Rotation Theorem</a>,-->
<!--</p>-->

<!--<p>-->
    <!--<br style="margin-bottom:10px;"/>-->
    <!--<div style="text-align: center">-->
        <!--<a href="/images/misc/transformations/rz.png">-->
            <!--<img src="/images/misc/transformations/rz.png" alt="Rotation matrix to rotate about axis-z by angle theta" align="middle" hspace="30" height="300">-->
        <!--</a>-->
        <!--<br/>-->
        <!--<figcaption>Rotation matrix to rotate about axis-z by angle theta</figcaption>-->
    <!--</div>-->
    <!--<br/>-->
<!--</p>-->


<!--<p>-->
    <!--<b>Step 3 - $R_{w}^{-1}$:</b>-->
    <!--<br/>-->
    <!--Since $R_{w}$ is a  rotation matrix with all its vectors being unit length, its inverse is its transpose matrix.-->
    <!--Therefore, $R_{w}^{-1} = R_{w}^{'}$.-->
<!--</p>-->

<!--&lt;!&ndash;##############&ndash;&gt;-->
<!--<hr>-->
<!--<p>-->
    <!--<big>-->
    <!--<b>Scaling:</b>-->
    <!--</big>-->
<!--</p>-->

<!--<p>-->
    <!--In order to scale the point $P_{A} = [x,  y,  z,  1]'$, by a scaling factor <code>sx sy sz</code>, following scaling-->
    <!--equation is used,-->
<!--</p>-->

<!--<p>-->
    <!--<br style="margin-bottom:10px;"/>-->
    <!--<div style="text-align: center">-->
        <!--<a href="/images/misc/transformations/s1.png">-->
            <!--<img src="/images/misc/transformations/s1.png" alt="Scaling equation" align="middle" hspace="30" height="300">-->
        <!--</a>-->
        <!--<br/>-->
        <!--<figcaption>Scaling equation</figcaption>-->
    <!--</div>-->
    <!--<br/>-->
<!--</p>-->



<!--&lt;!&ndash;##############&ndash;&gt;-->
<!--<hr>-->
<!--<p>-->
    <!--<big>-->
    <!--<b>Translation:</b>-->
    <!--</big>-->
<!--</p>-->

<!--<p>-->
    <!--In order to translate the point $P_{A} = [x,  y,  z,  1]'$, by a translation factor <code>tx ty tz</code>,-->
    <!--following translation equation is used,-->
<!--</p>-->

<!--<p>-->
    <!--<br style="margin-bottom:10px;"/>-->
    <!--<div style="text-align: center">-->
        <!--<a href="/images/misc/transformations/t1.png">-->
            <!--<img src="/images/misc/transformations/t1.png" alt="Scaling equation" align="middle" hspace="30" height="300">-->
        <!--</a>-->
        <!--<br/>-->
        <!--<figcaption>Translation equation</figcaption>-->
    <!--</div>-->
    <!--<br/>-->
<!--</p>-->



<!--&lt;!&ndash;##############&ndash;&gt;-->
<!--<hr>-->
<!--<p>-->
    <!--<big>-->
    <!--<b>Results:</b>-->
    <!--</big>-->
<!--</p>-->

<!--Here are some examples of .obj objects before and after applying the transformations. If you are interested, you could-->
<!--find <a href="-->
<!--https://console.cloud.google.com/storage/browser/project-data-store-public/csu-proj-data/comp-graphics/transformations/?pli=1">more examples here</a>-->
<!--or download directly from the the download links on-->
<!--<a href="https://www.cs.colostate.edu/~cs410/yr2018fa/more_assignments/assignment01.php">this page</a>.-->
<!--You will find 'driver' files in driver folder that describe what transformation to apply on which object file-->
<!--(from models folder). The corresponding outputs are stored in the driver_outputs in a folder named after the driver files.-->





<!--&lt;!&ndash;##############&ndash;&gt;-->
<!--<hr>-->
<!--<p>-->
    <!--<small>-->
    <!--<b>Note:</b>-->
    <!--Some of the content for this post is taken from course material of CS410 (CSU) written by Prof. Ross Beveridge.-->
    <!--</small>-->
<!--</p>-->
<!--<hr>-->